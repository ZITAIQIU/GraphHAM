import os
import pickle as pkl
import networkx as nx
import numpy as np
import scipy.sparse as sp
import torch



class HeteData():
    def __init__(self, data_root="data", dataset="DBLP", train_percent=None):
        """
        The datasets include DBLP, IMDB, and ACM.
        Edge_0, edge_1, edge_2, and edge_3 are lists of heterogeneous edges, while
        Edgelist is a list of homogeneous edges generated by discarding edge-type information.
        """
        self.dataset = dataset
        self.path = os.path.join(data_root, dataset)
        self.type_num = 3



        if os.path.exists(self.path):
            print("Dataset root: {}".format(self.path))
        else:            raise FileNotFoundError

        feature_path = self.path + '/node_features.pkl'

        with open(feature_path, 'rb') as f:
            self.x = pkl.load(f)
        self.hete_graph = []
        for i in range(4):
            self.hete_graph.append(
                nx.read_edgelist(self.path + "/edge_" + str(i), create_using=nx.DiGraph(), nodetype=int))
        '''
        Define meta-path according to the dataset
        The next_type dict ensure the correctness of meta-path connection
        '''

        if self.dataset in ['Twitter2012', 'Kawarith', 'Crisislext']:
            self.node_dict = {"T": 0, "U": 1, "E": 2}
            self.edge_type = {0: "TU", 1: "UT", 2: "TE", 3: "ET"}
            self.next_type = {0: [1], 1: [0, 2], 2: [3], 3: [0, 2]}

        label_path = self.path + '/labels'
        if train_percent != None:
            label_path += '_'
            label_path += str(train_percent)
        label_path += '.pkl'
        print("Label file:", label_path)

        with open(label_path, 'rb') as f:
            labels = pkl.load(f)
        
        self.train_list = np.array(labels[0], dtype=np.int_)
        self.val_list = np.array(labels[1], dtype=np.int_)
        self.test_list = np.array(labels[2], dtype=np.int_)

        test_idx_reorder = []

        for i in self.test_list:
            test_idx_reorder.append(i[0])


        tweet_feat = np.load(os.path.join(self.path + "/", 'tweet_features.npy'))
        tweet_feat = sp.coo_matrix(tweet_feat).tolil()
        tweet_feat = np.array(tweet_feat.todense())
        tweet_feat = self.normalize(tweet_feat)
        self.t_feat = torch.Tensor(tweet_feat)


    def get_dict_of_list(self):
        result = []
        for g in self.hete_graph:
            result.append(nx.to_dict_of_lists(g))
        return result

    def get_metapath_dict(self):
        return self.next_type

    def get_metapath_name(self):
        return self.edge_type

    def normalize(self, mx):
        """Row-normalize sparse matrix."""
        rowsum = np.array(mx.sum(1))
        r_inv = np.power(rowsum, -1).flatten()
        r_inv[np.isinf(r_inv)] = 0.
        r_mat_inv = sp.diags(r_inv)
        mx = r_mat_inv.dot(mx)
        return mx




